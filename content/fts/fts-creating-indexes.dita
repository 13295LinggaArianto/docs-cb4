<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_ksl_wwk_1v">
  
  <title>
    Creating Indexes
  </title>
  
  <shortdesc>
    Full Text Searches are supported by indexes, which can be created from the
    Couchbase Web Console.
  </shortdesc>
  
  <body>
    
    <section>
      
      <title>
        Indexes and Full Text Search
      </title>
      
      <p>
        Every Full Text Search is performed with reference
        to a user-created <i>index</i>. On creation of the index, 
        its elements are mapped to the
        documents and fields of a bucket. If the bucket contains
        documents of different <i>types</i> (for example, <codeph>airline</codeph> documents
        versus <codeph>hotel</codeph> documents), each document-type can be assigned its own
        index-mapping. Each index-mapping in turn can be assigned its own <i>analyzer</i>, can
        be applied to a specific subset of document-fields, and can be explicitly included in
        or excluded from the index.
        Searches can be performed across multiple buckets, by means
        of an <i>index alias</i>.
      </p>
      
    </section>
    
    <section>
      
      <title>
        Creating a Full Text Search Index
      </title>
      
      <p>
        Index-creation can be performed by means of the Couchbase Web Console. The basic
        procedure is outlined in 
        <xref href="./fts-searching-from-the-ui.dita" scope="local" format="dita">Searching from the UI</xref>.
        The current page explains the more
        advanced aspects of index-creation, and shows how they can be
        managed from the console.
      </p>
      
    </section>
    
    <section>
      
      <title>
        Accessing and Managing Full Text Search Indexes
      </title>
      
      <p>
        Full Text Search indexes are different from the <i>Global</i> indexes that are
        accessed under the <b>Indexes</b> tab in the left-hand navigation panel of the Couchbase
        Web Console. Full Text Search indexes are accessed from the <b>Search</b> tab: left-click on 
        this to display the <b>Full Text Search</b> panel, which
        contains a tabular presentation of currently existing indexes, with a row for each
        index. (See
        <xref href="./fts-searching-from-the-ui.dita" scope="local" format="dita">Searching from the UI</xref>.)
        To manage an index, left-click on its row. The row expands, as
        follows:
      </p>
      
      <p>
        <image href="./images/fts-index-management-ui.png" id="fts_index_management_ui" align="left" width="680"/>
      </p>
      
      <p>
        Three buttons are displayed:
      </p>
        
        <ul>
          
          <li>
            
            <uicontrol>Delete</uicontrol> causes the current index to be deleted.
            
            <p>
              
            </p>
            
          </li>
          
          <li>
            
            <uicontrol>Clone</uicontrol> brings up the <b>Clone Index</b> screen, which allows the a copy 
            of the current index to
            be modified (if necessary) and saved under a new name.
            
            <p>
              Note that both the <uicontrol>Edit Index</uicontrol> and <uicontrol>Clone Index</uicontrol>
              screens are in most respects the same as the <uicontrol>Add Index</uicontrol> screen,
              which was described in 
              <xref href="./fts-searching-from-the-ui.dita" scope="local" format="dita">Searching from the UI</xref>.
            </p>
            
          </li>
          
          <li>
            <uicontrol>Edit</uicontrol> brings up the <b>Edit Index</b> screen, which allows
            the index to be modified.
            Saving modifications causes the index to be rebuilt.
            
            <p>
              
            </p>
            
          </li>

        </ul>
      
    </section>
    
    <section>
      
      <title>
        Specifying Type Identifiers
      </title>
      
      <p>
        A <i>type identifier</i> allows the documents in a bucket to be identified by the index
        according to their <i>type</i>, as specified by the creator of the index. When the
        <uicontrol>Add Index</uicontrol>, <uicontrol>Edit Index</uicontrol>, or <uicontrol>Clone Index</uicontrol>
        screen is accessed, a <uicontrol>Type Identifer</uicontrol> panel is displayed:
      </p>
      
      <p>
        <image href="./images/fts-type-identifier-ui.png" id="fts_type_identifer_ui" align="left" width="460"/>
      </p>
      
      <p>
        Three options are provided, whereby the type of each document within the bucket can be
        identified by the index:
      </p>
      
      <ul>
        
        <li>
          <b>JSON type field</b>: The name of a document-field. The value
          of this field is used by the index to determine the type of the document. 
          The default field-name is <codeph>type</codeph>: meaning that the index searches for a field
          in each document whose name is <codeph>type</codeph>: each document that
          contains a field with
          that name is duly included in the index, with the 
          value of the field specifying the type of the document. Note that the value cannot be
          an array or JSON object.
          
          <p>
            
          </p>
          
        </li>
        
        
        <li>
          <b>Doc ID up to separator</b>: The characters in the ID of each document,
          up to but not including the separator. For example, if the document's
          ID is <codeph>hotel_10123</codeph>, the value <codeph>hotel</codeph> is
          determined by the index to be the type of the document.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <b>Doc ID with regex</b>: A regular expression that is applied by the
          index to the ID of each document. The resulting value is determined to
          be the type of the document. (This option may be used when the targeted document-subset
          features neither a <codeph>type</codeph> field nor an ID that follows
          a naming convention suitable for <b>Doc ID up to separator</b>.)
          
          <p>
            
          </p>
          
        </li>
        
      </ul>
      
    </section>
    
    <section>
      
      <title>
        Specifying Type Mappings
      </title>
      
      <p>
        Whereas a <i>type identifer</i> tells the index how to determine
        the position in each document of the characters 
        that specify the document's type, a <i>type mapping</i> specifies the 
        characters themselves. Thus, if <b>Doc ID up to separator</b> is used
        as a type identifier, a type mapping of <i>hotel</i> ensures that
        <codeph>hotel_10123</codeph>, rather than <codeph>airline_10</codeph>, is indexed
      </p>
      
      <p>
        When the
        <uicontrol>Add Index</uicontrol>, <uicontrol>Edit Index</uicontrol>, or <uicontrol>Clone Index</uicontrol>
        screen is accessed, the <uicontrol>Type Mappings</uicontrol> panel can be opened. The
        default setting is displayed:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-closed.png" id="fts_type_mappings_ui_closed" align="left" width="520"/>
      </p>
      
      <p>
        Left-click on the <uicontrol>+ Add Type Mapping</uicontrol> button. The display now
        appears as follows:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-add.png" id="fts_type_mappings_ui_add" align="left" width="520"/>
      </p>
      
      <p>
        The display indicates that a single type mapping is currently defined, which is 
        <codeph>default</codeph>. This is a special type mapping
        created by every index automatically: it is applied to each document 
        whose type <i>either</i> does not match a user-specified type mapping,
        <i>or</i> has no type attribute. Therefore, if the default mapping is
        left enabled, all documents are included in the index, regardless of
        whether the user actively specifies type mappings. To ensure that only
        documents corresponding to the user's specified type mappings are included
        in the index, the default type mapping must be disabled (see below for an
        example).
      </p>
      
      <p>
        To specify a type mapping, type the string (for example, <codeph>hotel</codeph>) 
        into the interactive text field. Note the <uicontrol>only index specified fields</uicontrol>
        checkbox: if this is checked, only specified fields from the document are
        included in the index. (See below for an example of specifying fields.)
      </p>
      
      <p>
        Optionally, an <i>analyzer</i> can be specified for the type mapping. A list of
        available analyzers can be accessed and selected from, by means of the pull-down
        menu, to the right of the interactive text-field:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-analyzers-menu.png" id="fts_type_mappings_ui_analyzers_menu" align="left" width="420"/>
      </p>
      
      <p>
        The default value, <codeph>inherit</codeph>, means that the type mapping inherits the
        default analyzer, specified in the <uicontrol>Advanced</uicontrol> panel, described
        below. Note that custom analyzers can be created and stored for the index undergoing
        definition, by means of the <uicontrol>Analyzers</uicontrol> panel, described below.
        All custom analyzers are available for association with a type mapping, and are
        thus added to the pull-down menu shown above.
      </p>
      
      <p>
        For more information on analyzers, see
        <xref href="./fts-using-analyzers.dita" scope="local" format="dita">Using Analyzers</xref>.
      </p>
      
      <p>
        Left-click on <uicontrol>OK</uicontrol> to save.
      </p>
      
      <p>
        The <uicontrol>Type Mappings</uicontrol> panel now appears as follows:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-addition-both-checked.png" id="fts_type_mappings_ui_addition_both_checked" align="left" width="420"/>
      </p>
      
      <p>
        Note that the checkbox to the left of each of the two specified type mappings,
        <codeph>hotel</codeph> and <codeph>default</codeph>, is checked. Because
        <codeph>deafult</codeph> is checked, <i>all</i> documents in the bucket (not
        merely those that correspond to the <codeph>hotel</codeph> type mapping) will be
        included in the index. To ensure that only <codeph>hotel</codeph> documents
        are included, <i>uncheck</i> the checkbox for <codeph>default</codeph>. The panel
        now appears as follows:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-addition-default-unchecked.png" id="fts_type_mappings_ui_addition_default_unchecked" align="left" width="420"/>
      </p>
      
      <p>
        Note also that should you wish to ensure that all documents in the bucket are included
        in the index <i>except</i> those that correspond to the <codeph>hotel</codeph> type
        mapping, <i>uncheck</i> the checkbox for <codeph>hotel</codeph>:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-addition-both-unchecked.png" id="fts_type_mappings_ui_addition_both_unchecked" align="left" width="420"/>
      </p>
      
      
    </section>
    
    <section>
      
      <title>
        Specifying Fields
      </title>
      
      <p>
        A Full Text Search Index can be defined not only to include (or exclude)
        documents of a certain <i>type</i>,
        but also to include (or exclude) specified <i>fields</i> within each of the typed 
        documents.
      </p>
      
      <p>
        To specify one or more fields, hover with the mouse cursor over a row in the
        <b>Type Mappings</b> panel that contains an enabled type mapping. Buttons labeled
        <uicontrol>edit</uicontrol> and <uicontrol>+</uicontrol> appear:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-fields-buttons.png" id="fts_type_mappings_ui_fields_buttons" align="left" width="420"/>
      </p>
      
      <p>
        Left-clicking on the <uicontrol>edit</uicontrol> button displays the following interface:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-edit.png" id="fts_type_mappings_ui_edit" align="left" width="420"/>
      </p>
      
      <p>
        This allows the mapping to be deleted, or associated with a different anlyzer. Left-clicking
        on the <uicontrol>+</uicontrol> button displays a pop-up that features two options:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-ui-field-options.png" id="fts_type_mappings_ui_field_options" align="left" width="420"/>
      </p>
      
      <p>
        These options are described in the following sections.
      </p>
      
    </section>
    
    <section>
      
      <title>
        Inserting a Child Field
      </title>
      
      <p>
        The option <uicontrol>insert child field</uicontrol> allows a field to be individually
        included for (or excluded from) indexing, provided that it contains a single value or an array, rather
        than a JSON object. Selecting this option displays the following:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-child-field-dialog.png" id="fts_type_mappings_child_field_dialog" align="left" width="420"/>
      </p>
      
      <p>
        The interactive fields and checkboxes are:
      </p>
      
      <ul>
        <li>
          <uicontrol>field</uicontrol>: The name of any field within the document that contains
          a single value or an array, rather than a JSON object.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <uicontrol>type</uicontrol>: The <i>data-type</i> of the value of the field. This can
          be <codeph>text</codeph>, <codeph>number</codeph>, <codeph>datetime</codeph>, <codeph>boolean</codeph>,
          <codeph>disabled</codeph>, or <codeph>geopoint</codeph>; and can be selected from the
          field's pull-down menu, as follows:
          
          <p>
            <image href="./images/fts-type-mappings-ui-select-data-type.png" id="fts_type_mappings_ui_select_data_type" align="left" width="200"/>
          </p>
          
        </li>
        
        <li>
          <uicontrol>searchable as</uicontrol>: Typically identical to the <uicontrol>field</uicontrol> (and
          dynamically supplied during text-input of the <uicontrol>field</uicontrol>-value. This can be
          modified, to extend one field-definition to another, and so include the additional field's value
          in the indexed content.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <uicontrol>analyzer</uicontrol>: The analyzer specifically to be used for the
          field. The list of available analyzers can be displayed by means of the
          field's pull-down muenu, and so selected from.
          
          <p>
            
          </p>
        </li>
        
        <li>
          <uicontrol>index</uicontrol>: When checked, the field is indexed; when unchecked,
          the field is not indexed.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <uicontrol>store</uicontrol>: When checked, the field-content is included in
          returned values; when unchecked, the field-content is not returned.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <uicontrol>include in _all field</uicontrol>: When checked, the field
          is included in the definition of <uicontrol>_all</uicontrol>, which is
          the field specified by default in the <uicontrol>Advanced</uicontrol>
          panel, as the target for indexing. When unchecked, the field is not so
          included.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <uicontrol>include term vectors</uicontrol>: When checked, term
          vectors are included. When unchecked, term vectors are not
          included.
          
          <p>
            
          </p>
          
        </li>
        
      </ul>
      
      <p>
        Note that when the value of the specified field is an array, the
        array-values are all indexed and searched individually: no special
        configuration is required.
      </p>
      
      <p>
        The dialog, when completed, might look as follows:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-child-field-dialog-complete.png" id="fts_type-mappings_child_field_dialog_complete" align="left" width="200"/>
      </p>
      
      <p>
        Left-click on <uicontrol>OK</uicontrol>. The field is saved, and its principal attributes
        displayed on a new row:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-child-field-saved.png" id="fts_type-mappings_child_field_saved" align="left" width="200"/>
      </p>
      
      <p>
        Note that when this row is hovered over with the mouse, an <uicontrol>Edit</uicontrol> button appears,
        whereby updates to the definition can be made.
      </p>
      
    </section>
    
    <section>
      
      <title>
        Inserting a Child Mapping
      </title>
      
      <p>
        The option <uicontrol>insert child mapping</uicontrol> specifies a field
        within the document whose value is a child-object. Selecting this option
        displays the following:
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-child-mapping-dialog.png" id="fts_type_mappings_child_mapping_dialog" align="left" width="420"/>
      </p>
      
      <p>
        The following interactive field and checkbox are displayed:
      </p>
      
      <ul>
        <li>
          <uicontrol>{}</uicontrol>: The name of a field whose value is a child-object. Note that
          an anlyzer can be specified for the field, by means of the pull-down menu.
          
          <p>
            
          </p>
          
        </li>
        
        <li>
          <uicontrol>only index specified fields</uicontrol>: When checked, only fields explicitly
          specified are added to the index. Note that the child-object that is the value the
          name entered for <uicontrol>{}</uicontrol> has multiple fields of its own. Checking this
          box ensures that a subset of these can be selected for indexing.
          
          <p>
            
          </p>
          
        </li>
        
      </ul>
      
      <p>
        When completed, the fields in this panel might look as follows. Note that <codeph>reviews</codeph> is
        a field within the <codeph>hotel</codeph>-type documents of the <codeph>travel-sample</codeph> bucket
        whose value is a child-object.
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-child-mapping-dialog-complete.png" id="fts_type_mappings_child_mapping_dialog_complete" align="left" width="420"/>
      </p>
      
      <p>
        Save by left-clicking <uicontrol>OK</uicontrol>. The field is now displayed as part of the
        <codeph>hotel</codeph> type mapping. Note that by hovering over the <codeph>reviews</codeph>
        row with the mouse, the <uicontrol>Edit</uicontrol> and <uicontrol>+</uicontrol> buttons
        are revealed: the <uicontrol>+</uicontrol> is present because <codeph>reviews</codeph> is
        an object that contains child-fields; which can now themselves be individually indexed.
      </p>
      
      <p>
        <image href="./images/fts-type-mappings-child-mapping-add-field.png" 
          id="fts_type_mappings_child_mapping_add_field.png" align="left" width="420"/>
      </p>
      
    </section>
    
    <section>
      
      <title>
        Creating Analyzers
      </title>
      
      <p>
        Analyzers increase search-awareness by transforming input text into token-streams, which
        allow richer and more finely controlled matching. An analyzer consists of modules, each of
        which performs a particular role in the transformation: modules are provided for removing
        undesirable characters; for transforming dictionary-based words into non-dictionary-based
        search tokens; and for performing miscellaneous post-processing activities. 
        For more information on analyzers, see
        <xref href="./fts-using-analyzers.dita" scope="local" format="dita">Using Analyzers</xref>.
      </p>
      
      <p>
        A default selection of analyzers is made available from the pull-down menu provided by the
        <uicontrol>Type Mappings</uicontrol> interface, discussed above. Additional analyzers can
        be custom-created, by means of the <uicontrol>Analyzers</uicontrol> panel, which appears
        as follows:
      </p>
      
      <p>
        <image href="./images/fts-analyzers-panel-initial.png" id="fts_analyzers_panel_initial" align="left" width="500"/>
      </p>
      
      <p>
        To create a new analyzer, left-click on the <uicontrol>+ Add Analyzer</uicontrol> button. The
        <b>Custom Analyzer</b> dialog appears:
      </p>
      
      <p>
        <image href="./images/fts-custom-analyzer-dialog-initial.png" id="fts_custom_analyzer_dialog_initial" align="left" width="360"/>
      </p>
      
      <p>
        The dialog contains four interactive panels.
      </p>
      
      <ul>
        <li>
          <b>Name</b>: A suitable name for the analyzer.
          
          <p>
            
          </p>
        </li>
        
        <li>
          <b>Character Filters</b>: One or more available character filters. (These
          strip out undesirable characters from input: for example, the <codeph>html</codeph> 
          character filter ignores HTML tags, and indexes HTML text-content alone.) To select from the
          list of available character filters, use the pull-down menu:
          
          <p>
            <image href="./images/fts-analyzers-panel-select-char-filter.png" id="fts_custom_analyzer_panel_select_char_filter" align="left" width="420"/>
          </p>
          
          <p>
            Following addition of one character filter, to add another, left-click
            on the <uicontrol>+ Add</uicontrol> button, to the right of the field.
          </p>
          
          <p>
            For an explanation of character filters, see
            <xref href="./fts-using-analyzers.dita" scope="local" format="dita">Using Analyzers</xref>.
          </p>
        </li>
        
        <li>
          <b>Tokenizer</b>: One of the available tokenizers. (These
          split input-strings into individual 
          <i>tokens</i>, which together are made into a <i>token stream</i>. Typically, 
          a token is established for each word.) The default value is
          <codeph>unicode</codeph>. To select from a list of all tokenizers available,
          use the pull-down menu:
          
          <p>
            <image href="./images/fts-add-tokenizer-pulldown.png" id="fts_add_tokenizer_pulldown" align="left" width="420"/>
          </p>
          
          <p>
            For more information on tokenizers, see
            <xref href="./fts-using-analyzers.dita" scope="local" format="dita">Using Analyzers</xref>.
          </p>
          
        </li>
        
        <li>
          <b>Token Filter</b>: One or more of the available token filters. (When specified, these
          are chained together, to perform additional post-processing on the token stream.) To select
          from the list of available filters, use the pull-down menu:
          
          <p>
            <image href="./images/fts-analyzers-panel-select-token-filter.png" id="fts_custom_analyzer_panel_select_token_filter" align="left" width="420"/>
          </p>
          
          <p>
            Following addition of one token filter, to add another, left-click
            on the <uicontrol>+ Add</uicontrol> button, to the right of the field.
          </p>
          
          <p>
            For more information on token filters, see
            <xref href="./fts-using-analyzers.dita" scope="local" format="dita">Using Analyzers</xref>.
          </p>
        </li>
        
      </ul>
      
      <p>
        Once these fields have been appropriately completed, save; by left-clicking
        on the <uicontrol>Save</uicontrol> button. On the <b>Edit Index</b> screen,
        the newly defined analyzer now appears in the <b>Analyzers</b> panel, with
        available options displayed for further editing, or deleting. For
        example:
      </p>
      
      <p>
        <image href="./images/fts-analyzers-panel-subsequent.png" id="fts_analyzers_panel_subsequent" align="left" width="500"/>
      </p>
      
    </section>
    
    <section>
      
       <title>
         Adding Custom Filters
       </title>
      
      <p>
        <i>Custom Filters</i> can be added, by means of the <b>Custom Filters</b>
        panel. When opened, this appears as follows:
      </p>
      
      <p>
        <image href="./images/fts-custom-filters-panel-initial.png" id="fts_custom_filters_panel_initial" align="left" width="500"/>
      </p>
      
      <p>
        The following four options are provided:
      </p>
      
      <ul>
        
        <li>
          <b>Character Filter</b>: Adds a new character filter to the list of those available. The new
          filter becomes available for inclusion in custom-created analyzers. Left-clicking on the
          <uicontrol>+ Add Character Filter</uicontrol> button displays the <b>Custom Character Filter</b>
          dialog:
          
          <p>
            <image href="./images/fts-custom-character-filter-dialog-initial.png" id="fts_custom_character_filter_dialog_initial" align="left" width="500"/>
          </p>
          
          <p>
            The following interactive fields are provided:
          </p>
          
          <ul>
            <li>
              <b>Name</b>: A suitable, user-defined name for the new character filter.
              
              <p>
                
              </p>
            </li>
            
            <li>
              <b>Type</b>: The type of filtering to be performed. Available options can be accessed
              from the pull-down menu, at the right of the field. (Currently, only <codeph>regexp</codeph>
              is available.)
              
              <p>
                
              </p>
              
            </li>
            
            <li>
              <b>Regular Expression</b>: The specific <i>regular expression</i> that the new character filter
              is to apply. Character-strings that match the expression will be affected, others will not.
              
              <p>
                
              </p>
              
            </li>
            
            <li>
              <b>Replacement</b>: The replacement text that will be substituted for each character-string match
              returned by the regular expression. If no replacement text is specified, the matched character-string
              will be omitted.
              
              <p>
                
              </p>
            </li>
            
          </ul>
          
          
          <p>
            The following completed fields define a character filter for deleting leading whitespace:
          </p>
          
          <p>
            <image href="./images/fts-custom-character-filter-dialog-filled.png" id="fts_custom_character_filter_dialog_filled" align="left" width="500"/>
          </p>
          
          <p>
            When saved, the new character filter is displayed on its own row, with options for further editing and deleting:
          </p>
           
          <p>
            <image href="./images/fts-custom-filters-panel-new-character-filter.png" id="fts_custom_filters_panel_new_character_filter.png" align="left" width="500"/>
          </p>
          
        </li>
        
      </ul>

      
    </section>
    
    
            
            
    <section id="fts-index-mapping"><title>Index Mapping</title>
      <p>The simplest way to create an index is to use the default index mapping with no further
        customization.  <term>Default index mapping</term>
        refers to the index mapping that Couchbase Server uses for JSON documents that don’t match a
        more specific document mapping based on document type. This example relies on dynamic
        mapping, explained later, to decide how to index the individual fields in the documents.
          <note type="warning">Using the default index mapping with dynamic mapping is a good way to
          ensure that full text search is working properly on a small set of data, but it’s not very
          selective so it tends to write a lot of information into the index. For this reason,
          default index mapping may be slow or result in high load if used on a production-sized
          dataset. </note></p><ol>
            <li>Click the button <uicontrol>Add Index</uicontrol>. <image placement="break"
              href="images/fts-create-index.png" width="745" id="image_x44_s1l_1v"/></li>
            <li>Give your index a name like "<userinput>beer-sample-idx</userinput>" and select the
              bucket you want to index from the drop-down list. <image placement="break"
                href="images/fts-create-index-2.png" width="540" id="image_s1h_x1l_1v"/></li>
        <li> Starting in version 4.6, you can create custom index mappings by document type when the
          type is specified in the document key. FTS uses the type identifier that you specify to
          determine where to find the type of each document. The type mapping then uses the value of
          type identifier for each document to determine which index mapping rules to apply. Select
          one of the three options for type identifier: "JSON type field", "Doc ID up to separator",
          and "Doc ID with regex".  <ul id="ul_tyx_xwy_ky">
            <li><b>JSON type field</b>: Specify the field in the JSON document whose value
              determines the type of the document. Defaults to "type". </li>
            <li><b>Doc ID up to separator</b>: The type identifier is the prefix of the document
              key, up to but not including the given character. </li>
            <li><b>Doc ID with regex</b>: For advanced users, you can specify a regular expression
              that matches the type identifier.</li>
          </ul><p>For example, the Doc ID up to the first underscore is considered the type identifier, so beer name, brewery name, and so on could be specified as type mappings. </p><image id="image_pjl_mxy_ky" href="images/fts-create-index-4.png" width="540" placement="break"></image></li>
        <li>If you click on "<uicontrol>Type Mappings</uicontrol>," you will only see one type
          listed, which is "<systemoutput>default</systemoutput>." </li>
            <li>Click the "<uicontrol>Create Index</uicontrol>" button. You will then see a screen that
              shows you how many documents are in your index and the percentage complete. <image
                placement="break" href="images/fts-create-index-3.png" width="918" id="image_zn3_1bl_1v"
              /></li>
            <li>Click on the row for that index and you can test searching the index you just created using the search text box.</li>
            <li>Your search shows the list of document IDs that contain the best matches for whatever search you ran, in order of score, with the highest scoring document listed first.</li>
          </ol>
    </section>
    <section><title>Custom Mapping</title>
      <p>There are many additional controls that can be used to build indexes on your documents just the
        way you want them. These can be found under <uicontrol>Search</uicontrol> > <b>Add Index</b> button or <uicontrol>Edit</uicontrol> 
        when you select an existing index row.</p>
      <p>Document mapping works as follows: <ol>
        <li>Specify the type of the document you want to include in your index. You can include more than 
          one type of document in a single index but you can only index documents in a single bucket. </li>
        <li> For each type of document, you specify how to index its fields and embedded structures. </li>
        <li>The term <parmname>field</parmname> refers to a name value pair in JSON where the value 
          is simple (i.e. not an object).  </li>
        <li>Use a <b>child mapping</b> to index embedded objects, i.e. name-value pairs where the
          value is of type object. You can add field mappings as in step 3 to describe how the
          name-value pairs in the embedded object should be indexed.</li>
        <li>To index arrays, use fields for arrays of simple values and use a child mapping for
            arrays of objects. In other words, you design your mapping so that you essentially
            ignore the array and FTS "just works" even though there are multiple values. For
            example, to index the following document containing an array, add a field of type
              <parmname>text</parmname> for <parmname>pachyderms</parmname>. Queries work just like
            any other field. If included in <codeph>_all</codeph>, a query for
              <parmname>rhinoceros</parmname> matches this document, or you can scope to the field
            using the normal field scoping syntax: <codeph>pachyderms:rhinoceros</codeph>.
            <codeblock outputclass="language-json">{
  "pachyderms": ["hippopotamus", "rhinoceros",  "elephant"]
}</codeblock></li>
      </ol></p>
      <p><b>Type Mappings</b></p>
      <p>Couchbase Server indexes JSON documents differently depending on the type of the JSON document.
        For example, you can create a full text index that only includes documents of
        type="brewery," and you can specify exactly how you want the documents mapped. To do this,
        click <uicontrol>Add Type Mapping</uicontrol> and enter a type name that matches the type
        attribute of the JSON document you want to index.</p><p>There is also a special type mapping for the <i>Default Type</i>. The default type mapping is created for every index automatically and is used for any document whose type does not match another type mapping or that doesn’t have a type attribute. <note>You must disable the default mapping if you <i>only</i> want documents of the types that you specify to be in the index. If default mapping is enabled, Couchbase Server will use it to include all the documents in your index that don’t match another type mapping, which may or may not be what you want.</note></p>
      <p>Each type mapping in an index definition can be enabled or disabled. Disabling a type
        mapping can be used to ignore documents of a certain type. For example, if you want to index
        all documents in the beer-sample bucket <i>except</i> "breweries" you could simply create a
        type mapping for breweries and then check disabled (assuming the default mapping is also
        disabled).</p>
      <p>You can also specify an analyzer to use for a type mapping. This defaults to inheriting the
        Default Analyzer specified in "<uicontrol>Advanced</uicontrol>".</p>
      <p><b>Field Mapping</b></p>
      <p>For any type mapping, you can insert a child field to index the values in your JSON
        document with more control about what appears in the index and how. The word "field" in
        index mapping refers to a name-value pair in JSON whose value is a simple type: string,
        number, true, false, or null. These child fields refer to name-value pairs that are directly
        under an object. In the brewery sample below, <parmname>name</parmname>,
        <parmname>city</parmname>, and <parmname>description</parmname> are all fields.</p>
      <p>You can index the <parmname>description</parmname> field of every document in the
        beer-sample bucket, you can create an index, hover over the <i>default index</i>, click on
        the plus that appears, and select "<uicontrol>Insert child field</uicontrol>". Because both
        beers and breweries have a description field, this default mapping will end up with every
        document in it.
        <codeblock outputclass="language-json">{
  "name": "21st Amendment Brewery Cafe",
  "city": "San Francisco",
  ...
  "description": "The 21st Amendment Brewery offers a variety of award winning house made brews and American grilled cuisine in a comfortable loft like setting. Join us before and after Giants baseball games in our outdoor beer garden. A great location for functions and parties in our semi-private Brewers Loft. See you soon at the 21A!",
  "address": [
    "563 Second Street"
    ],
  "geo": {
    "accuracy": "ROOFTOP",
    "lat": 37.7825,
    "lon": -122.393
  }
}</codeblock></p>
      <p>There are four values and four checkboxes you can specify when you insert a child field. <ul>
        <li><parmname>field</parmname>: The name of name-value pair in the JSON document.</li>
        <li><parmname>type</parmname>: Defaults to text, but other possible values are object,
          number, datetime, and disabled.</li>
        <li><parmname>searchable as</parmname>: You can change the name that is written into the
          index, so if a user limits their search to a specific field they would use this value
          instead of the actual name of the field in the JSON. For example, if we mapped the field
          <parmname>description</parmname> "searchable as" <parmname>info</parmname>, instead of
          typing "description:semi-private", users would instead search for "info:semi-private". </li>
        <li><parmname>analyzer</parmname>: The analyzer to use for this specific field. </li>
      </ul>In addition, there are four checkboxes: <ul>
        <li><uicontrol>index</uicontrol>: If unchecked, fields that match this will not be
          indexed. If the store checkbox is checked, they will still be stored.</li>
        <li><uicontrol>store</uicontrol>: Normally, only the document IDs are written to the
          index. If this is checked, the document contents are also written to the index. This
          enables highlighting and result snippets but generally results in larger indexes that
          are slower to build. Since gets and multi-gets are quite fast, usually users don’t need
          to store the additional information in the index.</li>
        <li><uicontrol>Include in _all field</uicontrol>: If this is checked, the text in this
          field will be searchable in query strings without prefixing the field name. If
          unchecked, the query must include this prefix, for example, "description:modern."</li>
        <li><uicontrol>include term vectors</uicontrol>: Term vectors are the locations of terms
          in a particular field. Some functionality, such as snippets, highlighting, and phrase
          search, requires term vectors and can’t be used without them. Not storing term vectors
          results in smaller indexes and faster index build times.</li>
      </ul> In this example, you would create the mapping like this:
        <codeblock outputclass="language-json">field: description
          type: text
          searchable as: description (automatically filled in)
          analyzer: inherit</codeblock>
        Check "<uicontrol>store</uicontrol>" so that all four checkboxes are checked. This makes it
        easier to test and debug your new index because search results will include snippets with
        the search terms highlighted. The downside of storing the information is the extra size and
        time it takes to build, but these should be acceptable in this case.</p>
      <p>Field is the name of the name-value pair in the JSON. In our example, the
        <parmname>description</parmname> property is at the top level but if you need to map
        name-value pairs that are embedded in complex structures, you need to use a <xref
          href="#topic_cmy_jzk_1v/child-mapping" format="dita">child mapping</xref> instead.</p>
      <p id="child-mapping"><b>Insert Child Mapping</b></p>
      <p>Child Mappings are similar to field mappings, but instead of indexing simple values, they enable you to index embedded structures in a JSON document. Use a child mapping when the value of  a name-value pair is an object.</p>
      <p>For example, consider the brewery document in the beer sample bucket. This document
        contains an embedded object called "geo" that has three fields: accuracy, lat, and lon.
        <codeblock outputclass="language-json">"geo": {
  "accuracy": "ROOFTOP",
  "lat": 37.7825,
  "lon": -122.393
}   </codeblock>
        To create an index with an object mapping for the geo structure using the Web Console, do
        the following:<ol>
          <li>Create a type mapping for breweries.</li>
          <li>Insert a child mapping for the attribute "<parmname>geo</parmname>".</li>
          <li>In the "<parmname>geo structure</parmname>", insert a child field for
              "<parmname>accuracy</parmname>".</li>
          <li>Insert child fields for "<parmname>lat</parmname>" and "<parmname>lon</parmname>" and
            set them to type <codeph>number</codeph>.</li>
          <li>In a search on your newly created index, you can search the accuracy field using a dot
            syntax: "<codeph>geo.accuracy:rooftop</codeph>".</li>
          <li>You can also do range searches on the geo fields: "<codeph>geo.accuracy:rooftop
              +geo.lat:>37 +geo.lon:>141</codeph>".</li>
        </ol>The index definition you created will look like the example below. You can create the
        same index definition with object mappings using the REST API:
        <codeblock outputclass="language-json">{
          "type": "fulltext-index",
          "name": "beer-idx",
          "uuid": "af4c073428d51ed5",
          "sourceType": "couchbase",
          "sourceName": "beer-sample",
          "sourceUUID": "a6e631d6c59692d8a8e4280615afd727",
          "planParams": {
          "maxPartitionsPerPIndex": 32,
          "numReplicas": 0,
          "hierarchyRules": null,
          "nodePlanParams": null,
          "pindexWeights": null,
          "planFrozen": false
          },
          "params": {
          "mapping": {
          "analysis": {
          "analyzers": {},
          "char_filters": {},
          "token_filters": {},
          "token_maps": {},
          "tokenizers": {}
          },
          "byte_array_converter": "json",
          "default_analyzer": "standard",
          "default_datetime_parser": "dateTimeOptional",
          "default_field": "_all",
          "default_mapping": {
          "display_order": "1",
          "dynamic": true,
          "enabled": false,
          "fields": [],
          "properties": {}
          },
          "default_type": "_default",
          "type_field": "type",
          "types": {
          "brewery": {
          "display_order": "0",
          "dynamic": false,
          "enabled": true,
          "fields": [],
          "properties": {
          "geo": {
          "display_order": "0",
          "dynamic": true,
          "enabled": true,
          "fields": [],
          "properties": {
          "accuracy": {
          "dynamic": false,
          "enabled": true,
          "fields": [
          {
          "analyzer": "",
          "date_format": null,
          "display_order": "2",
          "include_in_all": false,
          "include_term_vectors": true,
          "index": true,
          "name": "accuracy",
          "store": true,
          "type": "text"
          }
          ],
          "properties": {}
          },
          "lat": {
          "dynamic": false,
          "enabled": true,
          "fields": [
          {
          "analyzer": "",
          "date_format": null,
          "display_order": "1",
          "include_in_all": true,
          "include_term_vectors": true,
          "index": true,
          "name": "lat",
          "store": true,
          "type": "number"
          }      
          ],
          "properties": {}
          },
          "lon": {
          "dynamic": false,
          "enabled": true,
          "fields": [
          {
          "analyzer": "",
          "date_format": null,
          "display_order": "0",
          "include_in_all": true,
          "include_term_vectors": true,
          "index": true,
          "name": "lon",
          "store": true,
          "type": "number"
          }
          ],
          "properties": {}
          }
          }
          }
          }
          }
          }
          },
          "store": {
          "kvStoreName": "forestdb"
          }
          },
          "sourceParams": {
          "authPassword": "",
          "authSaslPassword": "",
          "authSaslUser": "",
          "authUser": "beer-sample",
          "clusterManagerBackoffFactor": 0,
          "clusterManagerSleepInitMS": 0,
          "clusterManagerSleepMaxMS": 2000,
          "dataManagerBackoffFactor": 0,
          "dataManagerSleepInitMS": 0,
          "dataManagerSleepMaxMS": 2000,
          "feedBufferAckThreshold": 0,
          "feedBufferSizeBytes": 0
          }
          }</codeblock></p>
      <p><b>Advanced Index Settings</b></p>
      <p><b>Type field </b></p>
      <p>By default, Couchbase Server will look for an attribute called "type" in your document and
        will use that for type mappings. You can change the name of the "type" field by clicking on
        the "<uicontrol>Advanced</uicontrol>" options and changing the value of the "<uicontrol>Type
          Field</uicontrol>".</p>
      <p><b>Default Type</b></p>
      <p>Documents that match the default type mapping rules are written to the index as being of
        this type. The field defaults to "<codeph>_default</codeph>", which you can change to avoid
        conflicts if "<codeph>_default</codeph>" is a valid type field value in your JSON
        documents.</p>
      <p><b>Default Analyzer  </b></p>
      <p>This analyzer is used by default when creating an index, if no other analyzer is specified.
        When you define your index mapping, you can override this value in a number of places, for
        example, when you create type mappings or field mappings.</p>
      <p><b>Default Date/Time Parser </b></p>
      <p>The name of a Date/Time parser that will be used to parse a date stored as a string.
          <note>Full text search and Bleve expect dates to be in the format specified by <xref
            href="https://www.ietf.org/rfc/rfc3339.txt" format="html" scope="external"
            >RFC-3339</xref>, which is a specific profile of ISO-8601 that is more restrictive.
        </note></p>
      <p id="def-field-all"><b>Default Field </b></p>
      <p>The default field is searched when a user query does not limit the scope of a search to a
        particular field. This is highly convenient because most of the time you want a user to be
        able to search for a term wherever it shows up in the index. For example, if you create a
        text index of breweries, as long as terms are included in the <codeph>_all</codeph> field,
        you can query "<codeph>La Jolla</codeph>" and find it without specifying "<codeph>name:la
          jolla</codeph>" or "<codeph>city:la jolla</codeph>". You would only need to change the
        name of this value if your JSON documents already include a field called
        "<codeph>_all</codeph>". </p>
    </section>
    <section id="index-alias"><title>Index Aliases</title>
        <p>An <term>index alias</term> is a special "virtual index" that points to other, real full text indexes.</p><p>Similar to a symbolic link in a file system, an index alias allows a naming level of indirection, so that applications can refer to a stable name (the alias' name) while administrators can dynamically re-target or re-point the index alias to different, real indexes. This can be useful for applications that are in production. For example, say you build an index my-index. You then build my-index-alias and point it to my-index. Your production application can search my-index-alias until you need to adjust the index, perhaps to change the index mapping or the analyzer. Any such change will require the index to be rebuilt, which would mean the current index will be out of commission.  Instead, you can clone the index and give it a new name, like my-better-index. Once this index has had the time to build, you can test it before putting it into production. If you decide it's ready, you then modify the definition of my-index-alias to remove my-index and instead point to my-better-index. By using an alias like this, the switch to my-better-index will be instantaneous and the index will already be fully ready to use. </p>
        <p>Similar to an email list alias, an index alias in FTS can also "fan-out" and refer to multiple, real indexes. Aliases can also refer to other aliases. A query on an index alias will be scatter-gathered by FTS to all of the actual, real indexes and FTS will provide merged results from those scatter-gathered queries.</p>
    </section>
  </body>
</topic>

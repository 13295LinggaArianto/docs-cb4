<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="java-fts">
    <title>
        Searching from the SDK
        
    </title>
    
    <titlealts>
        <navtitle>
            Searching from the SDK
        </navtitle>
    </titlealts>
    
    <shortdesc>
        The Java SDK provides an API that supports <i>Full Text Search</i>.
    </shortdesc>
    
    
    <body>
        
        <section id="using-full-text-search-from-the-java-sdk">
            
            <title>
                Using Full Text Search from the Java SDK
            </title>
            
            <p>
                By means of the Java SDK, Full Text Search queries can be performed on
                Full Text Indexes; and result-sets sorted.
            </p>
            
            <p>
                A general introduction to Full Text Search, with pointers to detailed descriptions of its
                principal features, is provided in
                <xref href="../../fts/full-text-intro.dita" scope="local" format="dita">Full Text Search: Fundamentals</xref>.
            </p>
            
            <p>
                The current page features a code example that demonstrates the Java SDK Full Text Search
                API. The example assumes that Couchbase Server is running, and that 
                the username <codeph>Administrator</codeph> and
                the password <codeph>password</codeph> provide authorization for performing the searches. 
                It also assumes that the <codeph>travel-sample</codeph> bucket
                has been installed. 
                For information on creating users and managing roles, see
                <xref href="../../security/security-authorization.dita" scope="local" format="dita">Authorization</xref>.
                For information on installing sample buckets, see
                <xref href="../../settings/settings.dita" scope="local" format="dita">Settings</xref>. 
            </p>
            
            <p>
                The example also assumes the existence of three specific Full Text Indexes, defined on the
                <codeph>travel-sample</codeph> bucket. These are:
            </p>
            
            <ul>
                <li>
                    <codeph>travel-sample-index-unstored</codeph>: Uses only the default 
                    settings.
                
                    <p>
                        
                    </p>
                
                </li>
                
                <li>
                    <codeph>travel-sample-index-stored</codeph>: Uses default settings, with one exception: 
                    dynamic fields are <i>stored</i>, for the whole index.
                    
                    <p>
                        
                    </p>
                    
                </li>
                
                <li>
                    <codeph>travel-sample-index-hotel-description</codeph>: Indexes only the <codeph>description</codeph> 
                    fields of <codeph>hotel</codeph>
                    documents, and disables the <codeph>default</codeph> type mapping. The index 
                    has a custom analyzer named <codeph>myUnicodeAnalyzer</codeph> defined on it: the analyzer's
                    main characteristic is that it uses the <b>unicode</b> tokenizer. 
                    
                    <p>
                        
                    </p>
                    
                </li>
            </ul>
            
            <p>
                See
                <xref href="../../fts/fts-creating-indexes.dita" scope="local" format="dita">Creating Indexes</xref>
                for details on how to create these indexes: they can be created interactively, by 
                means of the Couchbase Web Console. However, there may be greater efficiency in using the Couchbase REST 
                API, as described 
                in the section 
                <xref href="../../fts/fts-creating-indexes.dita#topic_ksl_wwk_1v/index-creation-with-the-rest-api" scope="local" format="dita">Index Creation with the REST API</xref>.
                The JSON objects that provide index-definitions, and should be specified as bodies to the REST calls, are provided in 
                <xref href="../../fts/fts-demonstration-indexes.dita" scope="local" format="dita">Demonstration Indexes</xref>.
            </p>
            
            <p>
                The example features fourteen Full Text Searches on the 
                <codeph>travel-sample</codeph> bucket, within Couchbase Server:
            </p>
            
            <ul>
                
                <li>
                    Query 1: <i>MatchQuery</i> on a single word, targeting an index with dynamic fields unstored.
                    
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 2: <i>MatchQuery</i> on a single word, specifying the field to be searched; targeting an index with dynamic 
                    fields stored, to ensure that field-content is included in the return object.
                    
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 3: <i>MatchQuery</i> on a series of words, specifying that a child-field be searched; targeting an 
                    index with dynamic 
                    fields stored. This query also defines two <i>facets</i>,
                    in order to return aggregation data, and demonstrates how the facet-data is retrieved from
                    the response object.
                    
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 4: <i>DocIdQuery</i> on two document IDs.
                    
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 5: <i>TermQuery</i> (which does not support analysis). <i>Zero fuzziness</i> is specified, to ensure
                    that matches are exact. The complete set of returned matches is displayed, and matched words are highlighted.                    
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 6: Another <i>TermQuery</i>, using a term identical to that used in Query 5. This time, a 
                    <i>fuzziness</i> factor of 2 is specified, allowing partial matches
                    to be made. The complete set of returned matches is displayed, and matched words are highlighted, so that the 
                    output can be compared to that of Query 5.
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 7: <i>MatchPhraseQuery</i>, for searching on a phrase.
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 8: <i>PhraseQuery</i>, for searching on a phrase (without analysis supported).
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 9: <i>MatchQuery</i> targeting an index that covers only a single field of a specified document. 
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 10: <i>ConjunctionQuery</i>, whereby two separate queries are defined and then run as part of the search,
                    with only the matches returned by both included in the result-object. 
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 11: <i>DisjunctionQuery</i>, whereby two separate queries are defined and then run as part of the search,
                    with only the matches <i>not</i> returned by both included in the result-object. 
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 12: <i>WildcardQuery</i>, whereby a wildcard is used in the string submitted for the search. 
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 13: <i>NumericRangeQuery</i>, whereby minimum and maximum numbers are specified, and matches
                    within the range returned. 
                    <p>
                        
                    </p>
                </li>
                
                <li>
                    Query 14: <i>RegexpQuery</i>, whereby a <i>regular expression</i> is submitted, to generate the conditions for
                    successful matches. 
                    <p>
                        
                    </p>
                </li>
                
            </ul>
        </section>
        
        <section id="java-fts-detailed-example">
            
            <title>
                Detailed Example
            </title>
            
            <p>
                The following, detailed example demonstrates a variety of Full Text Search queries that
                can be made with the Java SDK. See the comments in the code for further remarks on each.
            </p>
            
            <codeblock outputclass="language-java">package com.couchbase.example.fts;

import com.couchbase.client.java.Bucket;
import com.couchbase.client.java.Cluster;
import com.couchbase.client.java.CouchbaseCluster;
import com.couchbase.client.java.search.SearchQuery;
import com.couchbase.client.java.search.facet.SearchFacet;
import com.couchbase.client.java.search.queries.*;
import com.couchbase.client.java.search.result.SearchQueryResult;
import com.couchbase.client.java.search.result.SearchQueryRow;

public class FtsJavaClient 
{
    public static void main(String[] args) 
    {
        // Access the cluster that is running on the local host, authenticating with
        // the username and password of any user who has the "FTS Searcher" role
        // for the "travel-sample" bucket.
        //
        Cluster cluster = CouchbaseCluster.create("localhost");

        System.out.print("Authenticating as administrator." + "\n");
        cluster.authenticate("Administrator", "password");

        // Open the travel-sample bucket.
        //
        Bucket travelSample = cluster.openBucket("travel-sample");

        System.out.println();

        // For the successful running of the routines below, three indexes must exist on Couchbase
        // Server, all applied to the travel-sample bucket. Each of the index-definition files is
        // included in this repository. The first index, "travel-sample-index-unstored", uses all
        // the default settings. The second, "travel-sample-index-stored", is identical, except that
        // it has the "Store dynamic fields" box checked (in the "Advanced" settings area of the UI):
        // this allows content, potentially highlighted, to be returned.
        //
        // The third index, "travel-sample-index-hotel-description" only has the description fields
        // of hotel documents indexed.
        //
        // Query 1: A Match Query analyzes the input text and uses the result as the query-input.
        //
        MatchQuery myMatchQuery01 = SearchQuery.match("route");

        SearchQueryResult mySearchQueryResult01 = travelSample.query(
                new SearchQuery("travel-sample-index-unstored", myMatchQuery01).limit(10));

        System.out.println("Query 1 (MatchQuery on \"route\" in travel-sample-index-unstored): ");
        System.out.println();
        System.out.println("Note: The specified index was defined with dynamic fields \"unstored\", ");
        System.out.println("and so the output to this query does not include matching content: it "
                + "only shows doc IDs.");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult01) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 2. Again, a Match Query.
        //
        // Look for a match on the string "MDG" in
        // documents' "destinationairport" field. Limit the result-set to 10.
        //
        MatchQuery myMatchQuery02 = SearchQuery.match("MDG").field("destinationairport");

        SearchQueryResult mySearchQueryResult02 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myMatchQuery02).limit(10).highlight());

        System.out.println("Query 2 (MatchQuery on \"MDG\" in \"destinationairport\" fields of " +
                "travel-sample-index-stored): ");
        System.out.println();
        System.out.println("Note: The specified index was defined with dynamic fields \"stored\", and " +
                "so the output DOES show matching content as well as the doc IDs. Note also");
        System.out.println("that highlighting has been specified in the query, so that matched elements " +
                "in the content are highlighted with mark tags.");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult02) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 3. Again, a Match Query.
        //
        // Look for a match on the string "La Rue Saint Denis!!" in documents' "reviews.content"
        // field - note how "reviews.content" addresses a field nested within a sub-object in
        // the JSON document. Limit the result-set to 10.
        //
        MatchQuery myMatchQuery03 = SearchQuery.match("La Rue Saint Denis!!").field("reviews.content");

        SearchQueryResult mySearchQueryResult03 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myMatchQuery03)
                        .limit(10).highlight()

                        // Additionally, this query also demonstrates how to apply a "facet", whereby
                        // the incidence of a particular field across documents in the bucket (eg,
                        // "country", "city", "street") is calculated and displayed, with the incidence
                        // of each field-value displayed.
                        //
                        .addFacet("Countries Referenced", SearchFacet.term("country", 5))
                        .addFacet("Cities Referenced", SearchFacet.term("city", 5))
        );

        System.out.println("Query 3 (MatchQuery on \"La Rue Saint Denis!!\" in \"reviews.content\" " +
                "fields of travel-sample-index-stored): ");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult03) {
            System.out.println(row);
        }

        // An alternative way of displaying results.
        //
        System.out.println();
        System.out.println("Here, the same Query 3 results, but delivered as a list by the hits() " +
                "method on the SearchQueryResult object: ");
        System.out.println(mySearchQueryResult03.hits());

        System.out.println();
        System.out.println("Here, again from the Query 3 results, the 3 most frequently referenced " +
                "countries, then cities, accessed via a \"facet\":  ");
        System.out.println(mySearchQueryResult03.facets());

        System.out.println();
        System.out.println("Now here's all:");
        System.out.println(mySearchQueryResult03);


        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 4. On a docID.
        //
        DocIdQuery myDocIdQuery04 = SearchQuery.docId("hotel_26223", "hotel_28960");

        SearchQueryResult mySearchQueryResult04 = travelSample.query(
                new SearchQuery("travel-sample-index-unstored", myDocIdQuery04));

        System.out.println("Query 4: Result of a search on the docIDs \"hotel_26223\" and " +
                "\"hotel_28960\" for travel-sample-index-unstored: ");

        for (SearchQueryRow row : mySearchQueryResult04) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 5. On a term. Note that terms do not support analysis.
        //
        // Note that fuzziness is specified as 0. See Query 6, below, for a different
        // "fuzziness" specification.
        //
        TermQuery myTermIdQuery05 = SearchQuery.term("sushi").field("reviews.content")
                .fuzziness(0);

        SearchQueryResult mySearchQueryResult05 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myTermIdQuery05).limit(100)
                        .highlight());

        System.out.println("Query 5: (term-matches of \"sushi\" in \"reviews.content\" fields " +
                "of travel-sample-index-stored, with fuzziness of 0 producing exact matches): ");

        int x = 0;
        for (SearchQueryRow row : mySearchQueryResult05) {
            System.out.println(row);
            x++;
        }

        System.out.println("Number of rows returned for \"sushi\" with fuzziness of 0 is " + x);

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 6. On the same term as used for Query 5.
        //
        // Note that fuzziness is now specified as 2.
        //
        TermQuery myTermIdQuery06 = SearchQuery.term("sushi").field("reviews.content")
                .fuzziness(2);

        SearchQueryResult mySearchQueryResult06 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myTermIdQuery06).limit(100)
                        .highlight());

        System.out.println("Query 6: (term-matches of \"sushi\" in \"reviews.content\" fields of " +
                "travel-sample-index-stored, with fuzziness of 2 producing approximate matches): ");

        x = 0;
        for (SearchQueryRow row : mySearchQueryResult06) {
            System.out.println(row);
            x++;
        }

        System.out.println("Number of rows returned for \"sushi\" with fuzziness of 2 is " + x);

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 7. Match on a phrase.
        //
        //
        MatchPhraseQuery myMatchPhraseQuery07 = SearchQuery.matchPhrase("Eiffel Tower")
                .field("description");

        SearchQueryResult mySearchQueryResult07 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myMatchPhraseQuery07).limit(10)
                        .highlight());

        System.out.println("Query 7: (MatchPhrase query on \"Eiffel Tower\" in \"description\" fields " +
                "of travel-sample-index-stored): ");

        for (SearchQueryRow row : mySearchQueryResult07) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 8. Phrase query.
        //
        PhraseQuery myPhraseQuery08 = SearchQuery.phrase("dorm", "rooms")
                .field("description");

        SearchQueryResult mySearchQueryResult08 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myPhraseQuery08).limit(10).highlight());

        System.out.println("Query 8: (Phrase query on \"dorm\" and \"rooms\" in \"description\" fields "
                + "of travel-sample-index-stored): ");

        for (SearchQueryRow row : mySearchQueryResult08) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 9. Match with index that specifies the description field of the hotel-type
        // documents only.
        //
        MatchQuery myMatchQuery9 = SearchQuery.match("swanky");

        // The index travel-sample-index-hotel-description specifies that only the "description"
        // field of "hotel" documents be indexed.
        //
        SearchQueryResult mySearchQueryResult9 = travelSample.query(
                new SearchQuery("travel-sample-index-hotel-description", myMatchQuery9)
                        .limit(10)
        );

        System.out.println("Query 9 (MatchQuery on \"swanky\" in travel-sample-index-hotel-description: ");
        System.out.println("This index includes the description field of the hotel documents only");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult9) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 10. Conjunction-set of different match queries.
        //
        MatchQuery myMatchQueryForConjunctionNumber1 = SearchQuery.match("La Rue Saint Denis!!")
                .field("reviews.content");

        MatchQuery myMatchQueryForConjunctionNumber2 = SearchQuery.match("boutique")
                .field("description");

        // Create a conjunction query that takes the common subset of each of the two defined match queries.
        //
        ConjunctionQuery myConjunctionQuery10 = SearchQuery.conjuncts(myMatchQueryForConjunctionNumber1,
                myMatchQueryForConjunctionNumber2);

        SearchQueryResult mySearchQueryResult10 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myConjunctionQuery10)
                        .limit(10).highlight()
        );

        System.out.println("Query 10 (Conjunction of two match queries - \"La Rue Saint Denis!!\" and " +
                "\"boutique\", respectively on the \"reviews.content\" and \"description\" fields - of " +
                "travel-sample-index-stored): ");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult10) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 11: Query String Query. Note the specification of the target-field within the
        // query string.
        //
        QueryStringQuery myQueryStringQuery11 = SearchQuery.queryString("description: Imperial");

        SearchQueryResult mySearchQueryResult11 = travelSample.query(
                new SearchQuery("travel-sample-index-unstored", myQueryStringQuery11)
                        .limit(10)
        );

        System.out.println("Query 11 (Query String Query on travel-sample-index-unstored): ");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult11) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 12: Wildcard Query. Note the specification of the word "boutique", using
        // a wildcard-character.
        //
        WildcardQuery myWildcardQuery12 = SearchQuery.wildcard("bouti*ue")
                .field("description");

        SearchQueryResult mySearchQueryResult12 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myWildcardQuery12)
                        .limit(10).highlight()

        );

        System.out.println("Query 12 (WildcardQuery on travel-sample-index-stored): ");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult12) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 13: Numeric Range Query. Returns all documents whose id is between the stated minimum
        // and maximum values.
        //
        NumericRangeQuery myNumericRangeQuery13 = SearchQuery.numericRange().min(10100).max(10200)
                .field("id");

        SearchQueryResult mySearchQueryResult13 = travelSample.query(
                new SearchQuery("travel-sample-index-unstored", myNumericRangeQuery13)
                        .limit(10)
        );

        System.out.println("Query 13 (NumericRangeQuery on travel-sample-index-unstored): ");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult13) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // Query 14: Regexp Query.
        //
        //
        RegexpQuery myRegexpQuery14 = SearchQuery.regexp("[a-z]").field("description");

        SearchQueryResult mySearchQueryResult14 = travelSample.query(
                new SearchQuery("travel-sample-index-stored", myRegexpQuery14)
                        .limit(10).highlight()
        );

        System.out.println("Query 14 (RegexpQuery on travel-sample-index-stored): ");
        System.out.println();

        for (SearchQueryRow row : mySearchQueryResult14) {
            System.out.println(row);
        }

        System.out.println();
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println("= = = = = = = = = = = = = = = = = = = = = = =");
        System.out.println();

        // As administrator, disconnect from cluster.
        //
        System.out.println();
        System.out.println("Administrator disconnecting.");
        cluster.disconnect();
    }
}</codeblock>
        </section>

	</body>
</topic>

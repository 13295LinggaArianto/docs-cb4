<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="explain" xml:lang="en-US">
  <title>EXPLAIN</title>
    <shortdesc>Adding the EXPLAIN statement before any N1QL query provides information about the
    execution plan for that statement. You can also select the "Explain" button next to the
    "Execute" button for the same information.</shortdesc>
  <body>
    <section id="section_sxy_fkg_x1b">
      <title>RBAC Privileges</title>
      <p>
        <note>Users executing the EXPLAIN statement must have the privileges required for the N1QL
          statement that is being explained. For more details about user roles, see <xref
            href="../../security/security-authorization.dita#authorization"/>.<p><b>Example A</b>:
            To execute the following, you must have the <i>Query Insert</i> privilege on
              <codeph>`travel-sample`</codeph> and the <i>Query Select</i> privilege on
              <codeph>`beer-sample`</codeph>.<codeblock>EXPLAIN INSERT INTO `travel-sample` (KEY foo, VALUE bar) SELECT foo, bar FROM `beer-sample`</codeblock><b>Example
              B</b>: To execute the following, you must have the <i>Query Insert</i>, <i>Query
              Update</i>, and <i>Query Select</i> privileges on
            <codeph>testbucket</codeph>.<codeblock>EXPLAIN UPSERT INTO testbucket VALUES ("key1", { "a" : "b" }) RETURNING meta().cas</codeblock></p></note>
      </p>
    </section>
    <p>There are five different methods or views of the EXPLAIN functionality:<table frame="all"
        rowsep="1" colsep="1" id="table_wrq_pg3_x1b">
        <tgroup cols="2" align="left">
          <colspec colname="c1" colnum="1" colwidth="1*"/>
          <colspec colname="c2" colnum="2" colwidth="4*"/>
          <thead>
            <row>
              <entry>Method/View</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>JSON</entry>
              <entry>Details of the query plan in JSON format.</entry>
            </row>
            <row>
              <entry>Table</entry>
              <entry/>
            </row>
            <row>
              <entry>Tree</entry>
              <entry/>
            </row>
            <row>
              <entry>Plan</entry>
              <entry>Graphical representation of the query phases and operators.</entry>
            </row>
            <row>
              <entry>Plan Text</entry>
              <entry>Details of the query plan in JSON format.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>To demonstrate their differences, let's consider the following N1QL statement that
      queries and alphabetizes all landmarks in San
      Francisco:<codeblock>EXPLAIN SELECT name FROM `travel-sample` WHERE type="landmark" AND city="San Francisco" ORDER BY name;</codeblock></p>
    <section id="JSON_Output_and_Plan_Text_Output">
      <title>JSON Output and Plan Text Output</title>
      <p>Selecting either the "JSON" button or the "Plan Text" button will display the following
        JSON-formatted text listing the underlying query phases and operators:</p>
    </section>
    <image href="images/explain_QueryWorkbench_PlanText.png" id="image_kdv_lrp_x1b"/>
    <p><b>Example of JSON</b>: The full EXPLAIN details of querying all landmarks in San
      Francisco.</p>
    <codeblock>"results": 
{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
            "#operator": "IntersectScan",
            "scans": [
              {
                "#operator": "IndexScan2",
                "index": "def_city",
                "index_id": "d51323973a9c8458",
                "index_projection": {
                  "primary_key": true
                },
                "keyspace": "travel-sample",
                "namespace": "default",
                "spans": [
                  {
                    "exact": true,
                    "range": [
                      {
                        "high": "\"San Francisco\"",
                        "inclusion": 3,
                        "low": "\"San Francisco\""
                      }
                    ]
                  }
                ],
                "using": "gsi"
              },
              {
                "#operator": "IndexScan2",
                "index": "def_type",
                "index_id": "a11b1af8651888cf",
                "index_projection": {
                  "primary_key": true
                },
                "keyspace": "travel-sample",
                "namespace": "default",
                "spans": [
                  {
                    "exact": true,
                    "range": [
                      {
                        "high": "\"landmark\"",
                        "inclusion": 3,
                        "low": "\"landmark\""
                      }
                    ]
                  }
                ],
                "using": "gsi"
              }
            ]
          },
          {
            "#operator": "Fetch",
            "keyspace": "travel-sample",
            "namespace": "default"
          },
          {
            "#operator": "Parallel",
            "~child": {
              "#operator": "Sequence",
              "~children": [
                {
                  "#operator": "Filter",
                  "condition": "(((`travel-sample`.`type`) = \"landmark\") and ((`travel-sample`.`city`) = \"San Francisco\"))"
                },
                {
                  "#operator": "InitialProject",
                  "result_terms": [
                    {
                      "expr": "self",
                      "star": true
                    }
                  ]
                }
              ]
            }
          }
        ]
      },
      {
        "#operator": "Order",
        "sort_terms": [
          {
            "expr": "(`travel-sample`.`name`)"
          }
        ]
      },
      {
        "#operator": "FinalProject"
      }
    ]
  },
  "text": "SELECT * FROM `travel-sample` WHERE type=\"landmark\" AND city=\"San Francisco\" ORDER BY name;"
}</codeblock>
    <section id="section_iz5_dh3_x1b"><title>Table Output</title><p>This output groups #operator and
        scans in a table format:</p><image href="images/explain_QueryWorkbench_Table.png"
        id="image_tqw_kh3_x1b"/><p/></section>
    <section id="section_hlm_mh3_x1b"><title>Tree Output</title><p>This output lists the #operators
        and scans as a tree of ~children:</p><image href="images/explain_QueryWorkbench_Tree.png"
        id="image_azf_th3_x1b"/><p/></section>
    <section id="section_r2c_5h3_x1b"><title>Plan Output</title><p>This shows a graphical
        representation of the underlying query phases and operators. The Query Plan shows the steps
        the query optimizer chose. This plan is read left-to-right and then top-to-bottom, where the
        left side represents what the user sees and the right side represents the raw data before it
        undergoes operations. The data flow generally follows three steps:<ol id="ol_sqj_y34_x1b">
          <li>Action/Projection</li>
          <li>Source</li>
          <li>Filter</li>
        </ol></p><image href="images/explain_QueryWorkbench_Plan.png" id="image_ox4_3h4_x1b"
        /><p>Hovering over any unit of the plan shows more details of it. In this example
          query:<table frame="all" rowsep="1" colsep="1" id="table_zz5_333_x1b">
          <tgroup cols="2" align="left">
            <colspec colname="c1" colnum="1" colwidth="1*"/>
            <colspec colname="c2" colnum="2" colwidth="3*"/>
            <thead>
              <row>
                <entry>Unit name</entry>
                <entry>Information shown when hovered over</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Order</entry>
                <entry>{'#operator':'Order':'sort_terms':<p>[{'expr':'(`travel-sample`.`name`)'}]}</p></entry>
              </row>
              <row>
                <entry>Project</entry>
                <entry>{'#operator':'InitialProject':'result_terms':<p>[{'expr':'self','star':true}]}</p></entry>
              </row>
              <row>
                <entry>Filter</entry>
                <entry>{'#operator':'Filter','condition':'(((`travel-sample`.`type`) = \'landmark\')
                    and<p>((`travel-sample`.`city`) = \'San Francisco\'))'}</p></entry>
              </row>
              <row>
                <entry>Fetch</entry>
                <entry>{'#operator':'Fetch','keyspace':'travel-sample','namespace':'default'}</entry>
              </row>
              <row>
                <entry>IntersectScan</entry>
                <entry>(none)</entry>
              </row>
              <row>
                <entry>IndexScan2 (above)</entry>
                <entry>{'#operator':'IndexScan2','index':'def_city','index_id':'d51323973a9c8458','index_projection':<p>{'primary_key':true},'keyspace':'travel-sample','namespace':'default','spans':</p><p>[{'exact':true,'range':[{'high':'\San
                    Francisco\'','inclusion':3,'low':'\'San
                  Francisco\''}]}],'using':'gsi'}</p></entry>
              </row>
              <row>
                <entry>IndexScan2 (below)</entry>
                <entry>{'#operator':'IndexScan2','index':'def_city','index_id':'a11b1af8651888cf','index_projection':<p>{'primary_key':true},'keyspace':'travel-sample','namespace':'default','spans':</p><p>[{'exact':true,'range':[{'high':'\'landmark'\'','inclusion':3,'low':'\'landmark\''}]}],'using':'gsi'}</p></entry>
              </row>
            </tbody>
          </tgroup>
        </table>In general, the preference of scan is 1) Covering Index, 2) Index Scan, 3) Intersect
        Scan, 4) Union Scan, and finally 5) Fetch. </p></section>
    <section>
      <title>Simultaneous Scans</title>
      <p>When two filters are being applied, Couchbase Server will apply both of them simultaneously
        in different orders to see which is a more efficient method and will stop the slower filter
        process when the faster filter process finishes.</p>
      <p><b>Example 1</b>: In our San Francisco landmarks example, what's the best way to search and
        filter through 100,000 documents of <codeph>travel-sample</codeph> data?<ul
          id="ul_c1f_jv4_x1b">
          <li>Scan 1: Filters 10,000 documents of city San Francisco → then it filters to 50
            resulting documents of type landmark. (10,050 documents read)</li>
          <li>Scan 2: Filters 100 documents of type landmark → then it filters to 50 resulting
            documents of city San Francisco. (150 documents read)</li>
        </ul>Clearly, Scan 2 finishes much faster than Scan 1 did, so IntersectScan sends Scan 2's
        50 documents to the Fetch phase to be Projected and Ordered for the final output to the
        user.</p>
    </section>
  </body>
</topic>

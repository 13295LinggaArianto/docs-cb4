<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="explain" xml:lang="en-US">
  <title>EXPLAIN</title>
    <shortdesc>To produce a JSON output of the execution plan generated from a query text, you can
    either: 1) add the statement "EXPLAIN" before any N1QL query, or 2) select the <b>Explain</b>
    button. After entering Explain mode, you can either: 1) select the <b>JSON</b> button, or 2)
    select the <b>Plan Text</b> button. For details of planning and optimizing queries, see the
      <u><?oxy_custom_start type="oxy_content_highlight" color="255,255,0"?>Query
      Planner<?oxy_custom_end?></u> section. </shortdesc>
  <body>
    <section id="section_sxy_fkg_x1b">
      <title>RBAC Privileges</title>
      <p>
        <note>Users executing the EXPLAIN statement must have the privileges required for the N1QL
          statement that is being explained. For more details about user roles, see <xref
            href="../../security/security-authorization.dita#authorization"/>.<p><b>Example A</b>:
            To execute the following, you must have the <i>Query Insert</i> privilege on
              <codeph>`travel-sample`</codeph> and the <i>Query Select</i> privilege on
              <codeph>`beer-sample`</codeph>.<codeblock>EXPLAIN INSERT INTO `travel-sample` (KEY foo, VALUE bar) SELECT foo, bar FROM `beer-sample`</codeblock><b>Example
              B</b>: To execute the following, you must have the <i>Query Insert</i>, <i>Query
              Update</i>, and <i>Query Select</i> privileges on
            <codeph>testbucket</codeph>.<codeblock>EXPLAIN UPSERT INTO testbucket VALUES ("key1", { "a" : "b" }) RETURNING meta().cas</codeblock></p></note>
      </p>
    </section>
    <section id="section_zth_rcf_fbb">
      <title>Query Workbench</title>
      <p>In Query Workbench, there are five different views of the EXPLAIN functionality:<table
          frame="all" rowsep="1" colsep="1" id="table_wrq_pg3_x1b">
          <tgroup cols="2" align="left">
            <colspec colname="c1" colnum="1" colwidth="1*"/>
            <colspec colname="c2" colnum="2" colwidth="4*"/>
            <thead>
              <row>
                <entry>Method/View</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>JSON</entry>
                <entry morerows="1" valign="middle">Details of the query plan in JSON
                  format.</entry>
              </row>
              <row>
                <entry>Plan Text</entry>
              </row>
              <row>
                <entry>Table</entry>
                <entry morerows="2" valign="middle">Graphical representation of the query phases and
                  operators.</entry>
              </row>
              <row>
                <entry>Tree</entry>
              </row>
              <row>
                <entry>Plan</entry>
              </row>
            </tbody>
          </tgroup>
        </table>To demonstrate their differences, let's consider the following N1QL statement that
        queries the first 3 landmarks (after skipping one) in each city that contains the letter "n"
        and then groups them by city with the landmark names alphabetized and the total airports in
        each
        city:<codeblock>EXPLAIN SELECT DISTINCT name, city, count(airportname)
        FROM `travel-sample` airport
          JOIN `travel-sample` landmark
          ON KEY landmark.city FOR airport.city
        WHERE type="landmark" AND city LIKE "%n%"
        GROUP BY city
        ORDER BY name
        OFFSET 1
        LIMIT 10;</codeblock></p>
    </section>
    <p/>
    <section id="JSON_Output_and_Plan_Text_Output">
      <title>JSON / Plan Text Output</title>
      <p>Selecting either the <b>JSON</b> button or the <b>Plan Text</b> button will display
        JSON-formatted text of the underlying query phases and operators, such as:</p>
      <p><image href="images/explain_QueryWorkbench_PlanText.png" id="image_kdv_lrp_x1b"/></p>
    </section>
    <section id="section_kfh_1df_fbb"><title>Query Phases and Operators</title><p>Not all queries
        need to go through every phase, while some queries go through many of these phases multiple
        times. For example, the Sort phase can be skipped when there is no ORDER BY clause in the
        query, while the Scan-Fetch-Join phase will be used multiple times to perform multiple
        joins. </p><p>The below table summarizes all the Query Phases that might be used in an
        Execution Plan:<table frame="all" rowsep="1" colsep="1" id="table_q34_ldf_fbb">
          <tgroup cols="3" align="left">
            <colspec colname="c1" colnum="1" colwidth="2*"/>
            <colspec colname="c2" colnum="2" colwidth="5*"/>
            <colspec colname="c3" colnum="3" colwidth="1*"/>
            <thead>
              <row>
                <entry>Query Phases</entry>
                <entry>Description</entry>
                <entry>Remarks</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1. Parse</entry>
                <entry>Analyzes the query and available access path options for each keyspace in the
                  query to create a query plan and execution infrastructure. </entry>
                <entry>Done serially</entry>
              </row>
              <row>
                <entry>2. Plan</entry>
                <entry>Selects the access path, determines the Join order, determines the type of
                  Joins, and then creates the infrastructure needed to execute the plan.</entry>
                <entry>Done serially</entry>
              </row>
              <row>
                <entry>3. Scan</entry>
                <entry>Scans the data from the Index Service.</entry>
                <entry>Done in parallel</entry>
              </row>
              <row>
                <entry>4. Fetch</entry>
                <entry>Fetches the data from the Data Service.</entry>
                <entry>Done in parallel</entry>
              </row>
              <row>
                <entry>5. Join</entry>
                <entry>Joins the data from the Data Service.</entry>
                <entry>Done in parallel</entry>
              </row>
              <row>
                <entry>6. Filter</entry>
                <entry>Filters the result objects by specifying conditions in the WHERE
                  clause.</entry>
                <entry>Done serially</entry>
              </row>
              <row>
                <entry>7. Pre-Aggregate</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>8. Aggregate</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>9. Sort</entry>
                <entry>Orders and sorts items in the resultset in the order specified by the ORDER
                  BY clause.</entry>
                <entry/>
              </row>
              <row>
                <entry>10. Offset</entry>
                <entry>Skips the first n items in the result object as specified by the OFFSET
                  clause.</entry>
                <entry/>
              </row>
              <row>
                <entry>11. Limit</entry>
                <entry>Limits the number of results returned using the LIMIT clause.</entry>
                <entry/>
              </row>
              <row>
                <entry>12. Project</entry>
                <entry>Receives only the fields needed for final displaying to the user.</entry>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table>The below table summarizes all the Query Operators used in an Execution Plan:<table
          frame="all" rowsep="1" colsep="1" id="table_czw_qdf_fbb">
          <tgroup cols="3" align="left">
            <colspec colname="c1" colnum="1" colwidth="2*"/>
            <colspec colname="c2" colnum="2" colwidth="5*"/>
            <colspec colname="c3" colnum="3" colwidth="1*"/>
            <thead>
              <row>
                <entry>Query Operators</entry>
                <entry>Description</entry>
                <entry>Remarks</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Fetch</entry>
                <entry>Fetches the data from the Data Service.</entry>
                <entry/>
              </row>
              <row>
                <entry>Filter</entry>
                <entry>Filters the result objects by specifying conditions in the WHERE
                  clause.</entry>
                <entry>WHERE</entry>
              </row>
              <row>
                <entry>FinalGroup</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>FinalProject</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>IntersectScan</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>IndexScan</entry>
                <entry>A qualifying secondary index scan is used to first filter the keyspace and
                  determine the qualifying documents IDs. It then retrieves the documents from the
                  data store. In Couchbase, the secondary index can be a VIEW index or a global
                  secondary index (GSI).</entry>
                <entry>pre-5.0</entry>
              </row>
              <row>
                <entry>IndexScan2</entry>
                <entry/>
                <entry>5.0</entry>
              </row>
              <row>
                <entry>InitialGroup</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>InitialProject</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>IntermediateGroup</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>Join</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry><i>Key</i></entry>
                <entry>Specifies the document keys or using indexes to access the documents.</entry>
                <entry/>
              </row>
              <row>
                <entry>Keyscan</entry>
                <entry>When specific document IDs (keys) are available, Keyscan access method
                  retrieves documents for those IDs. The keyscan is commonly used to retrieve
                  qualifying documents on for the inner keyspace during join processing.</entry>
                <entry>USE KEYS</entry>
              </row>
              <row>
                <entry>Limit</entry>
                <entry>Limits the number of results returned using the LIMIT clause.</entry>
                <entry>LIMIT</entry>
              </row>
              <row>
                <entry>Offset</entry>
                <entry>Skips the first <varname>n</varname> items in the result object as specified
                  by the OFFSET clause.</entry>
                <entry>OFFSET</entry>
              </row>
              <row>
                <entry>Order</entry>
                <entry>Orders and sorts items in the resultset in the order specified by the ORDER
                  BY clause.</entry>
                <entry>ORDER BY</entry>
              </row>
              <row>
                <entry>Parallel</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry>PrimaryScan</entry>
                <entry>This is equivalent of full table scan in relational database systems.
                  Documents IDs are not given and no qualifying secondary access methods are
                  available for this keyspace. N1QL will apply applicable filters on each document.
                  This access method is quite expensive and the average time to return results
                  increases linearly with number of documents in the bucket.</entry>
                <entry/>
              </row>
              <row>
                <entry>Sequence</entry>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry/>
                <entry/>
                <entry/>
              </row>
              <row>
                <entry/>
                <entry/>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </table></p>The below table lists some of the common components used in an Execution
        Plan.<table frame="all" rowsep="1" colsep="1" id="table_ecw_mtk_fbb">
        <tgroup cols="3" align="left">
          <colspec colname="c1" colnum="1" colwidth="2*"/>
          <colspec colname="c2" colnum="2" colwidth="5*"/>
          <colspec colname="c3" colnum="3" colwidth="1*"/>
          <thead>
            <row>
              <entry>Query Component</entry>
              <entry>Description</entry>
              <entry>Remarks</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Aggregates</entry>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>Condition</entry>
              <entry>Arguments of the Operator.</entry>
              <entry/>
            </row>
            <row>
              <entry>Keyspace</entry>
              <entry>Specifies the keyspace that is queried. Ex: travel-sample</entry>
              <entry/>
            </row>
            <row>
              <entry>Namespace</entry>
              <entry>Specifies the namespace that is queried.</entry>
              <entry/>
            </row>
            <row>
              <entry>Seek</entry>
              <entry>Ex: null</entry>
              <entry/>
            </row>
            <row>
              <entry>Spans</entry>
              <entry>Specifies ranges, from "Low" to "High" and type of "Inclusion"</entry>
              <entry/>
            </row>
            <row>
              <entry>Using</entry>
              <entry>Ex: "gsi"</entry>
              <entry/>
            </row>
            <row>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry/>
              <entry/>
              <entry/>
            </row>
          </tbody>
        </tgroup>
      </table></section>
    <p/>
    <p><b>Example of JSON</b>: The full EXPLAIN details of querying all landmarks in San
      Francisco.</p>

              <codeblock>"results": 
{
  "plan": {
    "#operator": "Sequence",
    "~children": [
      {
        "#operator": "Sequence",
        "~children": [
          {
            "#operator": "IntersectScan",
            "scans": [
              {
                "#operator": "IndexScan2",
                "index": "def_city",
                "index_id": "d51323973a9c8458",
                "index_projection": {
                  "primary_key": true
                },
                "keyspace": "travel-sample",
                "namespace": "default",
                "spans": [
                  {
                    "exact": true,
                    "range": [
                      {
                        "high": "\"San Francisco\"",
                        "inclusion": 3,
                        "low": "\"San Francisco\""
                      }
                    ]
                  }
                ],
                "using": "gsi"
              },
              {
                "#operator": "IndexScan2",
                "index": "def_type",
                "index_id": "a11b1af8651888cf",
                "index_projection": {
                  "primary_key": true
                },
                "keyspace": "travel-sample",
                "namespace": "default",
                "spans": [
                  {
                    "exact": true,
                    "range": [
                      {
                        "high": "\"landmark\"",
                        "inclusion": 3,
                        "low": "\"landmark\""                             
                      }                                                     /
                    ]                                                       /
                  }                                                         /
                ],                                                          /
                "using": "gsi"                                              /
              }                                                             /
            ]                                                               /
          },                                                                /
          {                                                                 /
            "#operator": "Fetch",                                           /
            "keyspace": "travel-sample",                                    /
            "namespace": "default"                                          /
          },                                                                /
          {                                                                 /
            "#operator": "Parallel",                                        /
            "~child": {                                                     /
              "#operator": "Sequence",                                      /
              "~children": [                                                /
                {                                                           /
                  "#operator": "Filter",                                    /
                  "condition": "(((`travel-sample`.`type`) = \"landmark\")  /
                      and ((`travel-sample`.`city`) = \"San Francisco\"))"  /
                },
                {
                  "#operator": "InitialProject",
                  "result_terms": [
                    {
                      "expr": "self",
                      "star": true
                    }
                  ]
                }
              ]
            }
          }
        ]
      },
      {
        "#operator": "Order",
        "sort_terms": [
          {
            "expr": "(`travel-sample`.`name`)"
          }
        ]
      },
      {
        "#operator": "FinalProject"
      }
    ]
  },
  "text": "SELECT * FROM `travel-sample` WHERE type=\"landmark\" 
                      AND city=\"San Francisco\" ORDER BY name;"
}</codeblock>

    <section id="section_iz5_dh3_x1b"><title>Table Output</title><p>This N1QL-generated JSON output
        groups #operator and scans in a table format:</p><image
        href="images/explain_QueryWorkbench_Table.png" id="image_tqw_kh3_x1b"/><p/></section>
    <section id="section_hlm_mh3_x1b"><title>Tree Output</title><p>This N1QL-generated JSON output
        lists the #operators and scans as a tree of ~children:</p><image
        href="images/explain_QueryWorkbench_Tree.png" id="image_azf_th3_x1b"/><p/></section>
    <section id="section_r2c_5h3_x1b"><title>Plan Output</title><p>This shows a graphical
        representation of the underlying query phases and operators. The Query Plan shows the steps
        the query optimizer chose. This plan is read right-to-left and then top-to-bottom, where the
        right side represents the raw data before it undergoes operations and left side represents
        what the user sees. The data flow generally follows these steps:<ol id="ol_sqj_y34_x1b">
          <li>Scan</li>
          <li>Fetch</li>
          <li>Filter</li>
          <li>Projection (part 1)</li>
          <li>Order</li>
          <li>Projection (part 2)<note>Projection is split into two parts (one before Order and one
              after Order), but Query Workbench shows only the first part.</note></li>
        </ol></p><image href="images/explain_QueryWorkbench_Plan.png" id="image_ox4_3h4_x1b"
        /><p>Hovering over any unit of the plan shows more details of it. In this example
          query:<table frame="all" rowsep="1" colsep="1" id="table_zz5_333_x1b">
          <tgroup cols="2" align="left">
            <colspec colname="c1" colnum="1" colwidth="1*"/>
            <colspec colname="c2" colnum="2" colwidth="4*"/>
            <thead>
              <row>
                <entry>Unit name</entry>
                <entry>Information shown when hovered over</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Order</entry>
                <entry>{'#operator':'Order':'sort_terms':<p>[{'expr':'(`travel-sample`.`name`)'}]}</p></entry>
              </row>
              <row>
                <entry>Project</entry>
                <entry>{'#operator':'InitialProject':'result_terms':<p>[{'expr':'self','star':true}]}</p></entry>
              </row>
              <row>
                <entry>Filter</entry>
                <entry>{'#operator':'Filter','condition':'(((`travel-sample`.`type`) = \'landmark\')
                    and<p>((`travel-sample`.`city`) = \'San Francisco\'))'}</p></entry>
              </row>
              <row>
                <entry>Fetch</entry>
                <entry>{'#operator':'Fetch','keyspace':'travel-sample','namespace':'default'}</entry>
              </row>
              <row>
                <entry>IntersectScan</entry>
                <entry>(none)</entry>
              </row>
              <row>
                <entry>IndexScan2 (above)</entry>
                <entry>{'#operator':'IndexScan2','index':'def_city','index_id':'d51323973a9c8458','index_projection':<p>{'primary_key':true},'keyspace':'travel-sample','namespace':'default','spans':</p><p>[{'exact':true,'range':[{'high':'\San
                    Francisco\'','inclusion':3,'low':'\'San
                  Francisco\''}]}],'using':'gsi'}</p></entry>
              </row>
              <row>
                <entry>IndexScan2 (below)</entry>
                <entry>{'#operator':'IndexScan2','index':'def_city','index_id':'a11b1af8651888cf','index_projection':<p>{'primary_key':true},'keyspace':'travel-sample','namespace':'default','spans':</p><p>[{'exact':true,'range':[{'high':'\'landmark'\'','inclusion':3,'low':'\'landmark\''}]}],'using':'gsi'}</p></entry>
              </row>
            </tbody>
          </tgroup>
        </table>In general, the preference of scan is 1) Covering Index, 2) Index Scan, 3) Intersect
        Scan, 4) Union Scan, and finally 5) Fetch. </p></section>
    <section>
      <title>Simultaneous Scans</title>
      <p>Most operators work in parallel, each feeding the next in the pipeline. Some stages of the
        pipeline will be in parallel by multiple copies of the (or related) operator. Union scans
        will be parallelepiped as well.</p>
      <p>In our San Francisco landmarks example, two filters are being applied, and Couchbase Server
        will apply both of them simultaneously in different orders to see which is a more efficient
        method and will stop the slower filter process when the faster filter process finishes.</p>
      <p><b>Example 1</b>: What's the best way to search through and filter 100,000 documents of
          <codeph>travel-sample</codeph> data?<ul id="ul_c1f_jv4_x1b">
          <li>Scan 1: Filters 10,000 documents of city San Francisco → then it filters to 50
            resulting documents of type landmark. (10,050 documents read)</li>
          <li>Scan 2: Filters 100 documents of type landmark → then it filters to 50 resulting
            documents of city San Francisco. (150 documents read)</li>
        </ul>Clearly, Scan 2 finishes much faster than Scan 1 did, so IntersectScan sends Scan 2's
        50 documents to the Fetch phase to be Ordered and Projected for the final output to the
        user.</p>
    </section>
  </body>
</topic>
